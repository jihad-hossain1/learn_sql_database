# SkillHire: ER Diagram

```mermaid
erDiagram
    USERS {
        int user_id PK
        string email
        string password_hash
        string user_type
        timestamp created_at
        timestamp updated_at
        float average_rating "Denormalized for quick access"
    }
    FREELANCER_PROFILES {
        int freelancer_id PK, FK "FK to Users"
        string name
        string location
        float hourly_rate
        boolean availability
        jsonb portfolio
        jsonb skills "Denormalized for display"
    }
    CLIENT_PROFILES {
        int client_id PK, FK "FK to Users"
        string company_name
        string description
        string location
        string contact_info
    }
    CATEGORIES {
        int category_id PK
        string name
    }
    SKILLS {
        int skill_id PK
        string name
    }
    JOBS {
        int job_id PK
        int client_id FK "FK to Users"
        string title
        string description
        int category_id FK "FK to Categories"
        string budget_type
        float budget_amount
        date deadline
        string status
        timestamp created_at
        timestamp updated_at
        int application_count "Denormalized for performance"
        string category_name "Denormalized for display"

    }
    JOB_SKILLS {
        int job_id PK, FK "FK to Jobs"
        int skill_id PK, FK "FK to Skills"
    }
    APPLICATIONS {
        int application_id PK
        int job_id FK "FK to Jobs"
        int freelancer_id FK "FK to Users"
        string cover_letter
        float proposed_rate
        string status
        timestamp applied_at

    }
    PROJECTS {
        int project_id PK
        int job_id FK "FK to Jobs"
        int freelancer_id FK "FK to Users"
        string status
        date start_date
        date end_date
        float total_amount
        timestamp created_at
    }
    MILESTONES {
        int milestone_id PK
        int project_id FK "FK to Projects"
        string description
        date due_date
        float amount
        string status
        timestamp created_at
        timestamp updated_at
    }
    MESSAGES {
        int message_id PK
        int sender_id FK "FK to Users"
        int receiver_id FK "FK to Users"
        int job_id FK "FK to Jobs, optional"
        int project_id FK "FK to Projects, optional"
        string content
        timestamp sent_at
    }
    NOTIFICATIONS {
        int notification_id PK
        int user_id FK "FK to Users"
        string type
        string content
        boolean is_read
        timestamp created_at
    }
    REVIEWS {
        int review_id PK
        int project_id FK "FK to Projects"
        int reviewer_id FK "FK to Users"
        int reviewee_id FK "FK to Users"
        int rating
        string comment
        timestamp created_at
    }
    FREELANCER_SKILLS {
        int freelancer_id PK, FK "FK to Users"
        int skill_id PK, FK "FK to Skills"
    }
    ACTIVE_JOBS_VIEW ||--o{ JOBS : "View: Jobs with status='open'"
    TOP_FREELANCERS ||--o{ USERS : "Materialized View: Top-rated freelancers"

    USERS ||--o{ FREELANCER_PROFILES : has
    USERS ||--o{ CLIENT_PROFILES : has
    USERS ||--o{ JOBS : posts
    USERS ||--o{ APPLICATIONS : submits
    USERS ||--o{ PROJECTS : works_on
    USERS ||--o{ MESSAGES : sends
    USERS ||--o{ MESSAGES : receives
    USERS ||--o{ NOTIFICATIONS : receives
    USERS ||--o{ REVIEWS : writes
    USERS ||--o{ REVIEWS : receives
    USERS ||--o{ FREELANCER_SKILLS : has

    JOBS ||--o{ JOB_SKILLS : requires
    JOBS ||--o{ APPLICATIONS : receives
    JOBS ||--|| PROJECTS : leads_to

    PROJECTS ||--o{ MILESTONES : has

    CATEGORIES ||--o{ JOBS : categorizes

    SKILLS ||--o{ JOB_SKILLS : required_by
    SKILLS ||--o{ FREELANCER_SKILLS : possessed_by
```

---

## Design Decisions

### 1. Normalization and Denormalization

- **Normalization:**
  - The schema is normalized to at least Third Normal Form (3NF) to minimize redundancy and ensure data integrity.
  - Separate tables for `FREELANCER_PROFILES` and `CLIENT_PROFILES` allow for user-type-specific attributes, while both reference the `USERS` table.
  - Many-to-many relationships are handled by junction tables:
    - `JOB_SKILLS` links jobs and required skills.
    - `FREELANCER_SKILLS` links freelancers and their skills.
- **Denormalization:**
  - Some fields are denormalized for performance:
    - `JOBS.application_count` stores the number of applications for quick access.
    - `JOBS.category_name` avoids frequent joins with `CATEGORIES` for display.
    - `USERS.average_rating` allows fast retrieval of a userâ€™s rating.
    - `FREELANCER_PROFILES.skills` (JSONB) enables quick display of skills, complementing the normalized `FREELANCER_SKILLS` table.

### 2. Read-Heavy and Write-Heavy Tables

- **Read-Heavy Tables:**

  - `JOBS`: This table is frequently accessed by freelancers searching and browsing for available jobs. Since job listings are a core feature, optimizing for fast reads ensures a responsive user experience. The denormalized fields like `application_count` and `category_name` further reduce the need for expensive joins during these frequent reads.
  - `FREELANCER_PROFILES` and `CLIENT_PROFILES`: Profiles are often viewed by other users (clients viewing freelancers, freelancers viewing clients). Storing display-ready data (like denormalized skills in `FREELANCER_PROFILES`) allows for quick profile rendering.
  - `MESSAGES`: Messaging is a central feature, and users regularly check their conversations. Efficient reads are crucial for real-time chat and notifications.
  - `NOTIFICATIONS`: Users frequently check notifications for updates, so fast retrieval is important for engagement and timely alerts.

- **Write-Heavy Tables:**
  - `APPLICATIONS`: This table receives frequent writes as freelancers apply to jobs. The design supports high insert rates and ensures that application data is quickly available for both clients and freelancers.
  - `MESSAGES`: As users communicate, new messages are constantly being written. The schema supports high write throughput to maintain real-time communication.
  - `NOTIFICATIONS`: System and user actions generate notifications, resulting in frequent inserts. The structure allows for efficient batch and real-time notification creation.

### 3. Access Patterns and Rationale

- **Access Patterns:**

  - The schema is designed around the most common user actions: searching for jobs, viewing profiles, applying to jobs, messaging, and receiving notifications. By analyzing these patterns, the design ensures that the most frequent queries are efficient and require minimal joins or aggregations.
  - Many-to-many relationships (e.g., jobs and skills, freelancers and skills) are handled with junction tables (`JOB_SKILLS`, `FREELANCER_SKILLS`), enabling flexible querying and filtering without data duplication.
  - Denormalized fields (like `application_count`, `category_name`, and `average_rating`) are included to optimize for read-heavy scenarios, reducing the need for real-time computation or complex joins during high-traffic operations.
  - The separation of `FREELANCER_PROFILES` and `CLIENT_PROFILES` allows for tailored data storage and retrieval, supporting different user experiences and attributes for each user type.

- **Rationale for Structure:**
  - The structure prioritizes scalability and performance for a marketplace platform where read operations (browsing jobs, profiles, messages) vastly outnumber writes, but certain tables (applications, messages, notifications) must also handle high write volumes.
  - By balancing normalization (for data integrity and flexibility) with targeted denormalization (for speed), the schema supports both transactional consistency and fast, user-facing queries.
  - The use of junction tables and denormalized fields ensures that the system can efficiently support complex queries (e.g., "find all jobs requiring a specific skill" or "show a freelancer's average rating") without sacrificing maintainability or data quality.
  - This design enables the platform to deliver a responsive, reliable experience for both freelancers and clients, even as the user base and data volume grow.
