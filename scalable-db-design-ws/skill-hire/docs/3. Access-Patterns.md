# SkillHire: Access Patterns Examples

## Retrieve Freelancer Profiles

**Use Case:** Display a freelancer's complete profile information on their public profile page, including personal details, skills, and performance metrics.

**Description:** When a user visits a freelancer's profile page, the system needs to fetch comprehensive information including their basic details, skills, portfolio, and average rating. This information is displayed to help clients evaluate the freelancer's capabilities and experience.

**Access Pattern:** The query joins multiple tables to gather complete profile information. It aggregates skills into a JSON array for easy display and includes the denormalized average rating for quick access without real-time calculation.

**SQL:**

```sql
SELECT
    u.id,
    fp.name,
    fp.location,
    fp.hourly_rate,
    fp.is_available,
    fp.portfolio,
    json_agg(s.name) AS skills,
    u.average_rating
FROM
    users u
JOIN
    freelancer_profiles fp ON u.id = fp.id
LEFT JOIN
    freelancer_skills fs ON u.id = fs.freelancer_id
LEFT JOIN
    skills s ON fs.skill_id = s.id
WHERE
    u.id = :freelancer_id
GROUP BY
    u.id, fp.name, fp.location, fp.hourly_rate, fp.is_available, fp.portfolio, u.average_rating;
```

## Search Jobs with Filters and Full-Text Search

**Use Case:** Enable freelancers to discover relevant job opportunities by searching through available jobs using multiple criteria including keywords, categories, budget ranges, and required skills.

**Description:** Freelancers need an efficient way to find jobs that match their skills and preferences. The search functionality should support full-text search on job titles and descriptions, filter by job categories, budget constraints, and required skills. This helps freelancers quickly identify suitable opportunities without manually browsing through all available jobs.

**Access Pattern:** The query combines full-text search capabilities with multiple filtering options. It joins the jobs table with skills and categories to provide comprehensive search results that match the freelancer's criteria.

**SQL:**

```sql
SELECT
    j.id,
    j.title,
    j.description,
    j.budget_type,
    j.budget_amount,
    j.deadline,
    j.status,
    c.name AS category_name,
    json_agg(s.name) AS required_skills
FROM
    jobs j
LEFT JOIN
    categories c ON j.category_id = c.id
LEFT JOIN
    job_skills js ON j.id = js.job_id
LEFT JOIN
    skills s ON js.skill_id = s.id
WHERE
    j.status = 'open'
    AND (j.title ILIKE :search_term OR j.description ILIKE :search_term)
    AND (:category_id IS NULL OR j.category_id = :category_id)
    AND (:min_budget IS NULL OR j.budget_amount >= :min_budget)
    AND (:max_budget IS NULL OR j.budget_amount <= :max_budget)
GROUP BY
    j.id, j.title, j.description, j.budget_type, j.budget_amount, j.deadline, j.status, c.name
ORDER BY
    j.created_at DESC;
```

## Get Client's Open Jobs with Application Counts

**Use Case:** Provide clients with an overview of their active job postings, including the number of applications received for each job to help them understand the level of interest and manage their hiring process.

**Description:** Clients need to monitor their job postings to understand which positions are attracting the most interest and to manage their hiring workflow effectively. This view shows all open jobs posted by a specific client along with the application count for each job, helping clients prioritize which jobs to review first or identify jobs that may need more promotion.

**Access Pattern:** The query joins the jobs table with applications and uses aggregation to count applications per job. This provides a quick overview without requiring multiple database calls.

**SQL:**

```sql
SELECT
    j.id,
    j.title,
    j.description,
    j.budget_type,
    j.budget_amount,
    j.applications_count
FROM
    jobs j
WHERE
    j.client_id = :client_id
    AND j.status = 'open'
ORDER BY
    j.created_at DESC;
```

## Retrieve Freelancer's Applications with Job Details

**Use Case:** Show freelancers a comprehensive view of all their job applications, including job details and current application status, to help them track their job search progress.

**Description:** Freelancers need to keep track of all the jobs they've applied to, including the job details, application status, and when they applied. This helps them manage their job search, follow up on applications, and understand their application history over time.

**Access Pattern:** The query joins applications with jobs and categories to provide complete context for each application. Results are ordered by application date to show the most recent applications first.

**SQL:**

```sql
SELECT
    a.id,
    j.title,
    c.name AS category,
    a.status,
    a.applied_at
FROM
    applications a
JOIN
    jobs j ON a.job_id = j.id
LEFT JOIN
    categories c ON j.category_id = c.id
WHERE
    a.freelancer_id = :freelancer_id
ORDER BY
    a.applied_at DESC;
```

## Calculate Freelancer's Earnings Using CTE

**Use Case:** Compute the total earnings a freelancer has generated from completed projects, providing them with financial insights and performance metrics.

**Description:** Freelancers need to track their income and earnings over time. This calculation helps them understand their financial performance, set pricing strategies, and evaluate their success on the platform. The calculation only includes completed projects to provide accurate earnings data.

**Access Pattern:** Uses a Common Table Expression (CTE) to first filter completed projects, then aggregates the total earnings. This approach improves readability and performance by separating the filtering logic from the aggregation.

**SQL:**

```sql
WITH completed_projects AS (
    SELECT
        p.id,
        p.total_amount
    FROM
        projects p
    WHERE
        p.freelancer_id = :freelancer_id
        AND p.status = 'completed'
)
SELECT
    COALESCE(SUM(total_amount), 0) AS total_earnings
FROM
    completed_projects;
```

## Rank Freelancers by Average Rating Using Window Functions

**Use Case:** Create a leaderboard of freelancers ranked by their average rating to help clients identify top-performing freelancers and help freelancers understand their competitive position.

**Description:** Both clients and freelancers benefit from understanding how freelancers rank against each other based on their performance ratings. This ranking helps clients make informed hiring decisions and motivates freelancers to maintain high-quality work to improve their ranking.

**Access Pattern:** Uses window functions to assign rankings based on average rating in descending order. This provides a complete ranking without requiring multiple queries or complex application logic.

**SQL:**

```sql
SELECT
    u.id,
    fp.name,
    u.average_rating,
    RANK() OVER (ORDER BY u.average_rating DESC) AS rank
FROM
    users u
JOIN
    freelancer_profiles fp ON u.id = fp.id
WHERE
    u.user_type = 'freelancer';
```

## Get Top 5 Jobs by Application Count

**Use Case:** Identify the most popular job postings based on the number of applications received, helping understand market demand and job attractiveness.

**Description:** Understanding which jobs receive the most applications helps both clients and platform administrators. Clients can learn what makes certain jobs more attractive, while the platform can use this data for recommendations and market analysis. This information can also help freelancers understand which types of jobs are in high demand.

**Access Pattern:** Joins jobs with applications, aggregates by job, counts applications, and limits to the top 5 results. This provides a quick overview of the most sought-after positions.

**SQL:**

```sql
SELECT
    j.id,
    j.title,
    COUNT(a.id) AS application_count
FROM
    jobs j
JOIN
    applications a ON j.id = a.job_id
GROUP BY
    j.id, j.title
ORDER BY
    application_count DESC
LIMIT 5;
```

## Retrieve Client's Project History with Milestones

**Use Case:** Provide clients with a comprehensive view of all their projects, including milestone details and progress tracking, to help them manage their project portfolio.

**Description:** Clients need to track the progress of all their projects and understand how each project is progressing through its milestones. This view helps clients monitor project timelines, identify potential delays, and ensure projects are progressing as expected. It also provides historical context for future project planning.

**Access Pattern:** Joins projects with jobs and milestones to provide complete project context. Results are ordered by project start date and milestone due dates to show the most recent and relevant information first.

**SQL:**

```sql
SELECT
    p.id,
    j.title AS job_title,
    p.status,
    m.id AS milestone_id,
    m.description,
    m.due_date,
    m.amount,
    m.status AS milestone_status
FROM
    projects p
JOIN
    jobs j ON p.job_id = j.id
LEFT JOIN
    milestones m ON p.id = m.project_id
WHERE
    j.client_id = :client_id
ORDER BY
    p.start_date DESC, m.due_date;
```

## Find Freelancers with Specific Skills Using JSONB

**Use Case:** Quickly identify freelancers who possess specific skills stored in a JSONB field, enabling efficient skill-based searches for job matching.

**Description:** When clients need to find freelancers with specific skill sets, the system should be able to quickly search through freelancer profiles. Using JSONB for skills storage allows for flexible skill representation and efficient querying, especially when skills can be complex or hierarchical.

**Access Pattern:** Uses PostgreSQL's JSONB containment operator (@>) to efficiently search for freelancers whose skills include the required skill set. This approach leverages JSONB indexing for fast performance.

**SQL:**

```sql
SELECT
    id,
    name,
    skills
FROM
    freelancer_profiles
WHERE
    skills @> :required_skills::jsonb;
```

## Retrieve Unread Notifications for a User

**Use Case:** Display all unread notifications for a user to keep them informed about important events, messages, and system updates.

**Description:** Users need to stay informed about various events such as new messages, application updates, project milestones, and system notifications. The notification system should show only unread notifications to avoid overwhelming users with information they've already seen.

**Access Pattern:** Filters notifications by user ID and read status, ordering by creation date to show the most recent notifications first. This provides a clean, focused view of pending notifications.

**SQL:**

```sql
SELECT
    id,
    type,
    content,
    created_at
FROM
    notifications
WHERE
    user_id = :user_id
    AND is_read = false
ORDER BY
    created_at DESC;
```

## Calculate Average Time to Hire Using Window Functions

**Use Case:** Analyze the average time it takes for clients to hire freelancers from job posting to project start, providing insights into hiring efficiency.

**Description:** Understanding the time-to-hire metric helps both clients and the platform optimize the hiring process. Clients can benchmark their hiring speed against others, while the platform can identify bottlenecks in the hiring process and suggest improvements.

**Access Pattern:** Joins jobs with projects and calculates the average time difference between job creation and project start dates. This provides valuable insights into hiring process efficiency.

**SQL:**

```sql
SELECT
    j.client_id,
    AVG(p.start_date - j.created_at) AS avg_time_to_hire
FROM
    jobs j
JOIN
    projects p ON j.id = p.job_id
GROUP BY
    j.client_id;
```

## Retrieve Job Recommendations for Freelancers Based on Skills

**Use Case:** Suggest relevant job opportunities to freelancers based on their skill set, excluding jobs they've already applied to, to improve job matching and increase application rates.

**Description:** Freelancers benefit from personalized job recommendations that match their skills and experience. This feature helps freelancers discover relevant opportunities they might miss through manual browsing, while also helping clients find qualified candidates more quickly.

**Access Pattern:** Uses a CTE to identify matching jobs based on skill overlap, then excludes jobs the freelancer has already applied to. Results are ranked by the number of matching skills to show the most relevant opportunities first.

**SQL:**

```sql
WITH matching_jobs AS (
    SELECT
        j.id,
        j.title,
        COUNT(js.skill_id) AS matching_skills
    FROM
        jobs j
    JOIN
        job_skills js ON j.id = js.job_id
    WHERE
        js.skill_id IN (SELECT skill_id FROM freelancer_skills WHERE freelancer_id = :freelancer_id)
        AND j.status = 'open'
        AND j.id NOT IN (SELECT job_id FROM applications WHERE freelancer_id = :freelancer_id)
    GROUP BY
        j.id, j.title
)
SELECT
    id,
    title,
    matching_skills
FROM
    matching_jobs
ORDER BY
    matching_skills DESC
LIMIT 10;
```

## Get Freelancer's Project Completion Rate

**Use Case:** Calculate the percentage of projects a freelancer has successfully completed, providing a key performance metric for both freelancers and clients.

**Description:** Project completion rate is a crucial metric that indicates a freelancer's reliability and ability to deliver on commitments. This metric helps clients assess freelancer quality and helps freelancers understand their performance and areas for improvement.

**Access Pattern:** Uses conditional aggregation to count total projects and completed projects separately, then calculates the percentage. This provides a single, meaningful metric from multiple data points.

**SQL:**

```sql
SELECT
    COUNT(*) AS total_projects,
    SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) AS completed_projects,
    (SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS completion_rate
FROM
    projects
WHERE
    freelancer_id = :freelancer_id;
```

## Retrieve Client's Spending by Category

**Use Case:** Analyze a client's spending patterns across different job categories to help them understand their budget allocation and make informed decisions about future projects.

**Description:** Clients need to understand how they're allocating their budget across different types of work. This analysis helps them identify which categories they spend the most on, plan future budgets, and potentially optimize their spending patterns.

**Access Pattern:** Joins jobs, projects, and categories to aggregate spending by category. This provides a clear breakdown of spending patterns across different types of work.

**SQL:**

```sql
SELECT
    c.name AS category,
    SUM(p.total_amount) AS total_spent
FROM
    jobs j
JOIN
    projects p ON j.id = p.job_id
JOIN
    categories c ON j.category_id = c.id
WHERE
    j.client_id = :client_id
GROUP BY
    c.name;
```

## Find Freelancers with No Activity in Last 6 Months

**Use Case:** Identify freelancers who have been inactive for an extended period to help with platform maintenance, user engagement, and data quality management.

**Description:** Platform administrators need to identify inactive users for various purposes such as data cleanup, re-engagement campaigns, or understanding user retention patterns. This helps maintain platform quality and identify opportunities for user re-engagement.

**Access Pattern:** Uses NOT EXISTS subqueries to find freelancers who haven't submitted applications or started projects in the last 6 months. This approach efficiently identifies truly inactive users.

**SQL:**

```sql
SELECT
    u.id,
    fp.name
FROM
    users u
JOIN
    freelancer_profiles fp ON u.id = fp.id
WHERE
    u.user_type = 'freelancer'
    AND NOT EXISTS (
        SELECT 1 FROM applications a WHERE a.freelancer_id = u.id AND a.applied_at >= NOW() - INTERVAL '6 months'
    )
    AND NOT EXISTS (
        SELECT 1 FROM projects p WHERE p.freelancer_id = u.id AND p.start_date >= NOW() - INTERVAL '6 months'
    );
```

## Retrieve Job Application Details with Ranking

**Use Case:** List all applications for a specific job, ranked by proposed rate, to help clients evaluate candidates and make informed hiring decisions.

**Description:** When clients review applications for their job postings, they need to see all candidates with their proposed rates to make informed decisions. Ranking applications by rate helps clients understand the market value for their project and identify cost-effective candidates.

**Access Pattern:** Joins applications with user data and uses window functions to rank applications by proposed rate. This provides a clear ordering of candidates from lowest to highest bid.

**SQL:**

```sql
SELECT
    a.id,
    fp.name,
    a.proposed_rate,
    RANK() OVER (ORDER BY a.proposed_rate ASC) AS rate_rank
FROM
    applications a
JOIN
    freelancer_profiles fp ON a.freelancer_id = fp.id
WHERE
    a.job_id = :job_id
ORDER BY
    a.proposed_rate ASC;
```

## Calculate Cumulative Earnings Over Time for a Freelancer

**Use Case:** Show a freelancer's earnings accumulating over time to provide financial insights and help with income tracking and planning.

**Description:** Freelancers need to understand their income growth over time to make financial decisions, set goals, and track their success on the platform. Cumulative earnings provide a clear picture of income progression and help with financial planning.

**Access Pattern:** Uses window functions to calculate running totals of earnings over time. This provides a progressive view of income accumulation without requiring complex application logic.

**SQL:**

```sql
SELECT
    p.id,
    p.end_date,
    p.total_amount,
    SUM(p.total_amount) OVER (ORDER BY p.end_date) AS cumulative_earnings
FROM
    projects p
WHERE
    p.freelancer_id = :freelancer_id
    AND p.status = 'completed'
ORDER BY
    p.end_date;
```

## Retrieve Top 3 Skills in Demand

**Use Case:** Identify the most requested skills in job postings to help freelancers understand market demand and guide their skill development.

**Description:** Understanding which skills are most in demand helps freelancers make informed decisions about skill development and helps the platform provide market insights. This information can guide training recommendations and help freelancers position themselves competitively.

**Access Pattern:** Joins skills with job skills and aggregates by skill name to count demand. Results are limited to the top 3 to provide focused, actionable insights.

**SQL:**

```sql
SELECT
    s.name,
    COUNT(js.skill_id) AS demand_count
FROM
    skills s
JOIN
    job_skills js ON s.id = js.skill_id
GROUP BY
    s.name
ORDER BY
    demand_count DESC
LIMIT 3;
```

## Get Freelancer's Review History

**Use Case:** Display all reviews a freelancer has received from clients, providing transparency and helping build trust between freelancers and potential clients.

**Description:** Reviews are crucial for building trust and credibility on the platform. Freelancers need to showcase their review history to attract new clients, while potential clients need to see authentic feedback to make informed hiring decisions.

**Access Pattern:** Joins reviews with users, projects, and jobs to provide complete context for each review. Results are ordered by review date to show the most recent feedback first.

**SQL:**

```sql
SELECT
    r.id,
    fp.name AS reviewer_name,
    p.id AS project_id,
    j.title AS job_title,
    r.rating,
    r.comment,
    r.created_at
FROM
    reviews r
JOIN
    freelancer_profiles fp ON r.reviewer_id = fp.id
JOIN
    projects p ON r.project_id = p.id
JOIN
    jobs j ON p.job_id = j.id
WHERE
    r.reviewee_id = :freelancer_id
ORDER BY
    r.created_at DESC;
```

## Retrieve Client's Active Projects with Milestone Progress

**Use Case:** Show clients a comprehensive view of their active projects with milestone completion status to help them monitor project progress and identify potential issues.

**Description:** Clients need to track the progress of their active projects to ensure they're on schedule and identify any potential delays or issues early. This view provides a quick overview of project status and milestone completion to help with project management.

**Access Pattern:** Joins projects with jobs and milestones, using conditional aggregation to count total and completed milestones. This provides a clear progress overview for each active project.

**SQL:**

```sql
SELECT
    p.id,
    j.title AS job_title,
    COUNT(m.id) AS total_milestones,
    SUM(CASE WHEN m.status = 'completed' THEN 1 ELSE 0 END) AS completed_milestones
FROM
    projects p
JOIN
    jobs j ON p.job_id = j.id
LEFT JOIN
    milestones m ON p.id = m.project_id
WHERE
    j.client_id = :client_id
    AND p.status = 'in_progress'
GROUP BY
    p.id, j.title;
```

## Retrieve Job Postings with No Applications

**Use Case:** Identify job postings that haven't received any applications to help clients understand which jobs may need more promotion or adjustment.

**Description:** When jobs don't receive applications, it could indicate issues with job description, budget, requirements, or visibility. Identifying these jobs helps clients improve their job postings and helps the platform provide recommendations for job optimization.

**Access Pattern:** Uses a left join to identify jobs with no applications and filters for open jobs only. This helps identify jobs that may need attention or promotion.

**SQL:**

```sql
SELECT
    j.id,
    j.title,
    j.created_at
FROM
    jobs j
LEFT JOIN
    applications a ON j.id = a.job_id
WHERE
    a.id IS NULL
    AND j.status = 'open';
```

## Calculate Client's Average Project Budget

**Use Case:** Compute the average budget of a client's job postings to help them understand their typical project spending and plan future budgets.

**Description:** Understanding average project budgets helps clients make informed decisions about future projects and budget allocation. This metric provides insight into typical project costs and helps with financial planning.

**Access Pattern:** Uses aggregation to calculate the average budget amount for all jobs posted by a specific client. This provides a simple but valuable financial metric.

**SQL:**

```sql
SELECT
    AVG(budget_amount) AS average_budget
FROM
    jobs
WHERE
    client_id = :client_id;
```

## Retrieve Freelancer's Skill Gaps for a Job

**Use Case:** Identify skills that a freelancer lacks for a specific job to help them understand what additional skills they might need to develop or to help clients understand candidate limitations.

**Description:** When freelancers apply to jobs or when clients evaluate candidates, it's important to understand skill gaps. This helps freelancers identify areas for skill development and helps clients understand what training or support might be needed.

**Access Pattern:** Joins job skills with skills table and uses a subquery to exclude skills the freelancer already possesses. This provides a clear list of missing skills for a specific job.

**SQL:**

```sql
SELECT
    s.name AS missing_skill
FROM
    job_skills js
JOIN
    skills s ON js.skill_id = s.id
WHERE
    js.job_id = :job_id
    AND s.id NOT IN (
        SELECT skill_id FROM freelancer_skills WHERE freelancer_id = :freelancer_id
    );
```

## Retrieve Top Clients by Total Spending

**Use Case:** Identify the top-spending clients on the platform to help with business development, customer success, and platform analytics.

**Description:** Understanding which clients spend the most helps the platform prioritize customer success efforts and identify opportunities for business development. This information can also help freelancers identify high-value clients to target.

**Access Pattern:** Joins users, jobs, and projects to aggregate total spending by client, then limits to the top 5 spenders. This provides a clear ranking of the platform's most valuable clients.

**SQL:**

```sql
SELECT
    u.id,
    cp.company_name,
    SUM(p.total_amount) AS total_spent
FROM
    users u
JOIN
    client_profiles cp ON u.id = cp.id
JOIN
    jobs j ON u.id = j.client_id
JOIN
    projects p ON j.id = p.job_id
WHERE
    u.user_type = 'client'
GROUP BY
    u.id, cp.company_name
ORDER BY
    total_spent DESC
LIMIT 5;
```
